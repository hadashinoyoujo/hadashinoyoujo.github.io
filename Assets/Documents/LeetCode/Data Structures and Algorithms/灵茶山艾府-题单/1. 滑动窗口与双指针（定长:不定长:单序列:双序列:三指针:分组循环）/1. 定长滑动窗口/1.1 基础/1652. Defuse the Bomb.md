# 1652. Defuse the Bomb

## Method One

```c++
class Solution {
public:
    vector<int> decrypt(vector<int>& code, int k) {
        int n = code.size();
        vector<int> res(n, 0);

        for(int i = 0; i < n; ++i) {
            if(k > 0) {
                for(int j = i + 1; j < i + 1 + k; ++j) {
                    res[i] += code[j % n];
                }
            }
            else if(k < 0) {
                for(int j = i - 1; j > i - 1 - abs(k); --j) {
                    res[i] += code[((j % n) + n) % n];
                }
            }
        }

        return res;
    }
};
```

其中需注意：

1. 关于 $j$ 其实不需要想太多，让其持续累加或者累减就行，通过取模运算将坐标偏移回来。
2. 当 $k < 0$ 时，取模运算其实一样是可以的，只不过数组下标无法为负数，又因为本题限定条件是 $-(n - 1) <= k <= n - 1$，可见最多只有一个循环，所以可以加上 n 来将负数修正回正数区间。但这样又会导致原本在正数区间的坐标变大，所以再次使用取模运算，将变大的正数坐标修正回来。
3. 这种解法几乎没有用到滑动窗口的思路，纯考验数学思路。

### 复杂度解释

时间复杂度为：$O(n * |k|)$，当 k 接近 n 的时候，将退化为 $n^2$。



## Method Two



