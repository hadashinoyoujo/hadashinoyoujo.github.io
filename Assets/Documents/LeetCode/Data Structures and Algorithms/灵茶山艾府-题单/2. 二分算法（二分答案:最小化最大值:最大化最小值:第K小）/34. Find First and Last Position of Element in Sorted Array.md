# 34. Find First and Last Position of Element in Sorted Array

## Method One: Force

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int n = nums.size(), firstPos = -1, lastPos = -1;
        for(int i = 0; i < n; ++i) {
            if(nums[i] == target) {
                firstPos = i;
                break;
            }
        }
        for(int i = n - 1; i >= 0; --i) {
            if(nums[i] == target) {
                lastPos = i;
                break;
            }
        }
        return {firstPos, lastPos};
    }
};
```

### Note

1. 如果找不到则返回特定的值，一般在赋予初始值时就可以处理。

### Time Complexity

$O(n)$

### Space Complexity

$O(1)$



## Method Two: Binary Search Solution

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int firstPos = searchFirstEqual(nums, target);
        int lastPos = searchLastEqual(nums, target);
        return {firstPos, lastPos};
    }

    int searchFirstEqual(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1, mid = 0;
        bool existsTarget = false;
        while(left <= right) {
            mid = (left + right) / 2;
            if(nums[mid] < target) {
                left = mid + 1;
            }
            else if(nums[mid] > target) {
                right = mid - 1;
            }
            else {
                existsTarget = true;
                right = mid - 1;
            }
        }
        return existsTarget == true ? left : -1;
    }

    int searchLastEqual(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1, mid = 0;
        bool existsTarget = false;
        while(left <= right) {
            mid = (left + right) / 2;
            if(nums[mid] < target) {
                left = mid + 1;
            }
            else if(nums[mid] > target) {
                right = mid - 1;
            }
            else {
                existsTarget = true;
                left = mid + 1;
            }
        }
        return existsTarget == true ? (left - 1) : -1;
    }
};
```

### Note

1. 循环不变量：每次循环都会遵守的条件。举例来说，无论循环开始还是结束时，`L - 1` 一定小于 `target`，而 `R + 1` 一定大于等于 `target`。具体论证见 [二分查找 红蓝染色法 【基础算法精讲 04】](https://www.bilibili.com/video/BV1AP41137w7/?vd_source=cf5ef38829abdf09b933af13ed3b3275)。
2. 本题的核心就在于循环不变量，另外便是“当 `nums[mid] == target` 时，边界如何变化。“或者可以换种说法：“当 `nums[mid] == target` 时，由哪个边界去追？”，可以看到，需要求第一个等于 `target` 的元素的位置时，由 `right` 去追，需要求最后一个等于 `target` 的元素时，由 `left` 去追。由谁去追，就说明，当循环结束时，谁的上一步一定是答案。在 `searchFirstEqual` 中，`right` 的上一步是 `right + 1`，当然，如果在数组中找不到 `target`，就要看题目要求怎么处理了；在 `searchFirstBigger` 中，`left` 的上一步是 `left - 1`。

### Time Complexity

$O(log n)$

由于每次搜索会使范围缩小一半，且需要用到两个独立的二分查找，忽略常数 2，答案就是 log n

### Space Complexity

$O(1)$